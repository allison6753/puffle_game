#include "main.h"

#include <stdio.h>
#include <stdlib.h>

/* TODO: */
// fix button stuff!

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:

//screen images
#include "images/start_screen.h"
#include "images/snow_scene.h"

//penguin image
#include "images/penguin.h"

//puffle images
#include "images/blue_puffle.h"
#include "images/pink_puffle.h"
#include "images/green_puffle.h"
#include "images/brown_puffle.h"
#include "images/yellow_puffle.h"
#include "images/gray_puffle.h"
#include "images/purple_puffle.h"
#include "images/white_puffle.h"
#include "images/red_puffle.h"



/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
 

  // initailize penguin
  struct penguin player;
  struct penguin *playerP = &player;
  playerP -> row = 130;
  playerP -> col = 150;
  playerP -> width = PENGUIN_WIDTH;
  playerP -> height = PENGUIN_HEIGHT;
  playerP -> image = penguin;

  // initialize puffles
  int initialHorDis[3] = {2,-1,0};
  int initialVertDis[3] = {-1,0,2};
  const short unsigned int *images[3] = {pink_puffle, blue_puffle, yellow_puffle}; //, green_puffle, white_puffle, red_puffle, gray_puffle, brown_puffle, purple_puffle};
  struct puffle puffles[3];
  for (int i = 0; i < 3; i++) {
    puffles[i].row = (i * BLUE_PUFFLE_HEIGHT) % HEIGHT;
    puffles[i].col = (i * BLUE_PUFFLE_WIDTH) % WIDTH;
    puffles[i].height = BLUE_PUFFLE_HEIGHT;
    puffles[i].width = BLUE_PUFFLE_WIDTH;
    puffles[i].vertDis = initialVertDis[i];
    puffles[i].horDis = initialHorDis[i];
    puffles[i].show = 1;
    puffles[i].image = images[i];
  }


  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    //reset game
    if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
      state = START;
    }

    waitForVBlank();

    switch (state) {

      case START:
        drawFullScreenImageDMA(start_screen);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          drawFullScreenImageDMA(snow_scene);
          state = PLAY;
          
        }
        break;


      case PLAY:

        drawImageDMA(playerP -> row, playerP -> col, playerP -> width, playerP -> height, playerP -> image);

        for (int i = 0; i < 3; i++) {
          if (puffles[i].show) {
            undrawImageDMA(puffles[i].row, puffles[i].col, puffles[i].row + puffles[i].height, puffles[i].col + puffles[i].width, snow_scene);
          }
        }
          

        for (int i = 0; i < 3; i++) {
          if (puffles[i].row + puffles[i].vertDis < 0 || puffles[i].row + puffles[i].vertDis > HEIGHT - puffles[i].height) {
            puffles[i].vertDis = -puffles[i].vertDis;
          }
          if (puffles[i].col + puffles[i].horDis < 0 || puffles[i].col + puffles[i].horDis > WIDTH - puffles[i].width) {
            puffles[i].horDis = -puffles[i].horDis;
          }
          puffles[i].row += puffles[i].vertDis;
          puffles[i].col += puffles[i].horDis;
          drawImageDMA(puffles[i].row, puffles[i].col, puffles[i].width, puffles[i].height, puffles[i].image);
        }
        
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
          //BUTTONS = BUTTONS & ~BUTTON_UP;
          for (int i = 0; i < 3; i++) {
            if (puffles[i].row >= 5) {
              int maxMove = 5;
              for (int x = 0; x < 3; x++) {
                int distance = puffles[i].row - puffles[x].row - puffles[i].height;
                if (distance > 0 && distance < maxMove) {
                  maxMove = distance;
                }
              }
              puffles[i].row -= maxMove;
              undrawImageDMA(puffles[i].row + puffles[i].height, puffles[i].col, puffles[i].row + puffles[i].height + maxMove, puffles[i].col + puffles[i].width, snow_scene);
            }
          }
          
        }
        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
          //BUTTONS = BUTTONS & ~BUTTON_DOWN;
          for (int i = 0; i < 3; i++) {
            if (puffles[i].row <= HEIGHT - 5 - puffles[i].height) {
              int maxMove = 5;
              for (int x = 0; x < 3; x++) {
                int distance = puffles[x].row - puffles[i].row - puffles[i].height;
                if (distance > 0 && distance < maxMove) {
                  maxMove = distance;
                }
              }
              puffles[i].row += maxMove;
              undrawImageDMA(puffles[i].row - maxMove, puffles[i].col, puffles[i].row, puffles[i].col + puffles[i].width, snow_scene);
            }
          }
          
        }
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
          //BUTTONS = BUTTONS & ~BUTTON_LEFT;
          for (int i = 0; i < 3; i++) {
            if (puffles[i].col >= 5) {
              int maxMove = 5;
              for (int x = 0; x < 3; x++) {
                int distance = puffles[i].col - puffles[x].col - puffles[i].width;
                if (distance > 0 && distance < maxMove) {
                  maxMove = distance;
                }
              }
              puffles[i].col -= maxMove;
              undrawImageDMA(puffles[i].row, puffles[i].col + puffles[i].width, puffles[i].row + puffles[i].height, puffles[i].col + puffles[i].width + maxMove, snow_scene);
            }
          }
        }
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
          //BUTTONS = BUTTONS & ~BUTTON_RIGHT;
          for (int i = 0; i < 3; i++) {
            if (puffles[i].col <= WIDTH - 5 - puffles[i].width) {
              int maxMove = 5;
              for (int x = 0; x < 3; x++) {
                int distance = puffles[i].col - puffles[x].col - puffles[i].width;
                if (distance > 0 && distance < maxMove) {
                  maxMove = distance;
                }
              }
              puffles[i].col += maxMove;
              undrawImageDMA(puffles[i].row, puffles[i].col - maxMove, puffles[i].row + puffles[i].height, puffles[i].col - 1, snow_scene);
            }
          }
        }

			// break;

        // state = ?
        break;
      case WIN:

        // state = ?
        break;
      case LOSE:

        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
