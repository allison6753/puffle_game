#include "main.h"

#include <stdio.h>
#include <stdlib.h>

/* TODO: */
// fix button stuff!

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:

// screen images
#include "images/start_screen.h"
#include "images/snow_scene.h"
#include "images/win_screen.h"

// penguin image
#include "images/penguin.h"

// puffle images
#include "images/blue_puffle.h"
#include "images/pink_puffle.h"
#include "images/green_puffle.h"
#include "images/brown_puffle.h"
#include "images/yellow_puffle.h"
#include "images/gray_puffle.h"
#include "images/purple_puffle.h"
#include "images/white_puffle.h"
#include "images/red_puffle.h"



/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
 

  // initailize penguin
  struct penguin player;
  struct penguin *playerP = &player;
  playerP -> row = 130;
  playerP -> col = 150;
  playerP -> width = PENGUIN_WIDTH;
  playerP -> height = PENGUIN_HEIGHT;
  playerP -> image = penguin;

  // initialize puffles
  int initialHorDis[9] = {2, -1, 0, 1, 1, -2, 3, -2, -3};
  int initialVertDis[9] = {-1, 0, 2, 3, -2, 1, -3, 1, -2};
  const short unsigned int *images[9] = {pink_puffle, blue_puffle, yellow_puffle, green_puffle, white_puffle, red_puffle, gray_puffle, brown_puffle, purple_puffle};
  struct puffle puffles[9];
  for (int i = 0; i < 9; i++) {
      puffles[i].row = (i * BLUE_PUFFLE_HEIGHT) % HEIGHT;
      puffles[i].col = (i * BLUE_PUFFLE_WIDTH) % WIDTH;
      puffles[i].height = BLUE_PUFFLE_HEIGHT;
      puffles[i].width = BLUE_PUFFLE_WIDTH;
      puffles[i].vertDis = initialVertDis[i];
      puffles[i].horDis = initialHorDis[i];
      puffles[i].show = 1;
      puffles[i].image = images[i];
  }

  // initialize score
  int score = 0;


  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    // reset game
    if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
      state = START;
    }

    if (score == 9) {
      state = WIN;
    }

    waitForVBlank();

    switch (state) {

      case START:
        drawFullScreenImageDMA(start_screen);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          drawFullScreenImageDMA(snow_scene);
          state = PLAY;
        }
        break;


      case PLAY:
        // draw penguin
        drawImageDMA(playerP -> row, playerP -> col, playerP -> width, playerP -> height, playerP -> image);

        // draw score
        char buffer[51];
        sprintf(buffer, "Score: %d", score);
        drawString(150, 185, buffer, BLUE);

        // undraw old puffles
        for (int i = 0; i < 9; i++) {
          if (puffles[i].show) {
            undrawImageDMA(puffles[i].row, puffles[i].col, puffles[i].row + puffles[i].height, puffles[i].col + puffles[i].width, snow_scene);
          }
        }
          
        // draw new puffles
        for (int i = 0; i < 9; i++) {

          if (!puffles[i].show) continue;

          // check for collision
          if (abs(puffles[i].row - (playerP -> row)) < 30 && abs(puffles[i].col - (playerP -> col)) < 25) {
            puffles[i].show = 0;
            score++;

            // undraw old score
            undrawImageDMA(150, 185, 160, 240, snow_scene);

            continue;
          }

          if (puffles[i].row + puffles[i].vertDis < 0 || puffles[i].row + puffles[i].vertDis > HEIGHT - puffles[i].height) {
            puffles[i].vertDis = -puffles[i].vertDis;
          }
          if (puffles[i].col + puffles[i].horDis < 0 || puffles[i].col + puffles[i].horDis > WIDTH - puffles[i].width) {
            puffles[i].horDis = -puffles[i].horDis;
          }
          puffles[i].row += puffles[i].vertDis;
          puffles[i].col += puffles[i].horDis;
          drawImageDMA(puffles[i].row, puffles[i].col, puffles[i].width, puffles[i].height, puffles[i].image);

        }


        // up button
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
          //BUTTONS = BUTTONS & ~BUTTON_UP;
          if ((playerP -> row) >= 3) {
            playerP -> row -= 3;
            undrawImageDMA((playerP -> row) + (playerP -> height), (playerP -> col), (playerP -> row) + (playerP -> height) + 3, (playerP -> col) + (playerP -> width), snow_scene);
          }
        }

        // down button
        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
          //BUTTONS = BUTTONS & ~BUTTON_DOWN;
          if ((playerP -> row) <= HEIGHT - (playerP -> height) - 3) {
            playerP -> row += 3;
            undrawImageDMA(playerP -> row - 3, (playerP -> col), (playerP -> row), (playerP -> col) + (playerP -> width), snow_scene);
          }
        }

        // left button
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
          //BUTTONS = BUTTONS & ~BUTTON_LEFT;
          if ((playerP -> col) >= 3) {
            playerP -> col -= 3;
            undrawImageDMA(playerP -> row, (playerP -> col) + (playerP -> width), (playerP -> row) + (playerP -> height), (playerP -> col) + (playerP -> width) + 3, snow_scene);
          }
        }

        // right button
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
          //BUTTONS = BUTTONS & ~BUTTON_RIGHT;
          if ((playerP -> col) <= WIDTH - (playerP -> width) - 3) {
            playerP -> col += 3;
            undrawImageDMA(playerP -> row, (playerP -> col) - 3, (playerP -> row) + (playerP -> height), (playerP -> col) - 1, snow_scene);
          }
        }

        break;


      case WIN:
        drawFullScreenImageDMA(win_screen);
        // state = ?
        break;


      case LOSE:

        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
